#!/bin/bash
# This script is used to compare your working .env file with an example
# .env file and show all variables that each has that the other is
# missing.  Used so that when environment variables are added:
# 1) The developer adding the variable remembers to add it to the template
# 2) Other developers will be made aware of the new variable when they pull the changed template.
#
# This does not typically need to be called directly, it is called from
# the env_files_run_all_checks script which runs all necessary checks.

{
    # Get the path to the directory where this script is located so other 
    # scripts can be sourced from this script relative to it's own path.
    declare SCRIPT_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    
    # Used to count the number of action items (TODOs) found
    # while comparing .env and verifying the .env file.
    declare ACTION_ITEM_COUNT=0
}

# Import common functions and variables for scripts
source "$SCRIPT_PATH/common-functions.sh"

# Function to extract keys (env variable names) from a .env file
# Usage: extract_keys <env_file>
extract_keys() {
    local file="$1"
    grep -o '^[^#]*' "$file" | grep '=' | cut -d '=' -f 1 | sort | uniq
}

# Get the value of a single environment variable from a .env file
# Usage: env_get_var_value <env_var_name>
env_get_var_value() {
    local env_var="$1"
    grep "^${env_var}=*" ".env" | cut -d'=' -f2
}

# Compares two .env files and print the keys that are missing from each file.
# Usage: env_check_missing_vars <env_file1> <env_file2>
env_check_missing_vars() {
    local env_file1="$1"
    local env_file2="$2"
    local original_action_item_count="$ACTION_ITEM_COUNT"
    log_output "Comparing $env_file1 and $env_file2 for missing env vars..." "$COLOR_BLUE"
        
    # Extract keys from both .env files
    keys_file1=$(extract_keys $env_file1)
    keys_file2=$(extract_keys $env_file2)
    
    # Convert the keys to arrays
    keys_array1=($keys_file1)
    keys_array2=($keys_file2)
    
    # Find keys missing from .env2 that are present in .env1
    for key in "${keys_array1[@]}"; do
        if ! [[ " ${keys_array2[*]} " =~ " $key " ]]; then
            log_output "[TODO] [MISSING FROM $env_file2] $key" "$COLOR_RED"
            ACTION_ITEM_COUNT=$((ACTION_ITEM_COUNT + 1))
            actions_found="$COLOR_RED"
        fi
    done
    
    # Find keys in .env2 that are not in .env1
    for key in "${keys_array2[@]}"; do
        if ! [[ " ${keys_array1[*]} " =~ " $key " ]]; then
            log_output "[TODO] [MISSING FROM $env_file1] $key" "$COLOR_RED"
            ACTION_ITEM_COUNT=$((ACTION_ITEM_COUNT + 1))
            output_color="$COLOR_RED"
        fi
    done
    
    if [ "$ACTION_ITEM_COUNT" -eq "$original_action_item_count" ]; then
        log_output "Complete." "$COLOR_GREEN"
    fi
    
}

# Function to create a .env file from a template if it does not exist
# Usage: env_create_file <env_file> <env_file_template>
env_create_file() {
    local env_file="$1"
    local env_file_template="$2"
    log_output "Checking for existing .env file..." "$COLOR_BLUE"
    
    if [ ! -f "$env_file" ]; then
        log_output "${env_file} file not found, creating from template..."
        cp "$env_file_template" "$env_file"
        log_output "Created file [$env_file] from template [$env_file_template]" "$COLOR_GREEN"
    else
        log_output "Found existing .env file, no action required." "$COLOR_GREEN"
    fi
}

# Function to generate a random password for environment variables
# that are flagged to be autogenerated via the <AUTOGENERATE_PASSWORD> placeholder.
# Uses a temporary file to store the new .env file while they are being generated.
# Usage: env_generate_passwords <env_file> <env_file_tmp>
env_generate_passwords() {
    local env_file="$1"
    local env_file_tmp="$2"
    log_output "Checking for environment variables flagged to autogenerate..." "$COLOR_BLUE"
    
    # Read the .env file line by line
    rm -f "$env_file_tmp"
    
    while IFS= read -r line || [ -n "$line" ]; do
        # Check if the line contains the placeholder <AUTOGENERATE_PASSWORD>
        if [[ "$line" == *"=<AUTOGENERATE_PASSWORD>"* ]]; then
            # Get the name of the env variable currently being auto-generated
            CURRENT_ENV_KEY=$(echo "$line" | cut -d '=' -f 1)
            log_output "Generating random value for $CURRENT_ENV_KEY"
            # Generate a unique password
            new_password=$(generate_password)
            # Replace the placeholder with the generated password
            line=${line//=<AUTOGENERATE_PASSWORD>/=$new_password}
        fi
    
        # Print the line (this will be redirected to a new file later)
        echo "$line" >> "$env_file_tmp"
    done < "$env_file"
    
    # Replace the original .env file with the modified temporary one
    log_output "Replacing original .env file with updated version..."
    mv "$env_file_tmp" "$env_file"
    
    log_output "Complete." "$COLOR_GREEN"
}

# Function to check for environment variables that require manual input
# and log them as action items.
# Usage: env_check_missing_values <env_file>
env_check_missing_values() {
    local env_file="$1"
    local original_action_item_count="$ACTION_ITEM_COUNT"
    log_output "Checking for environment variables flagged to require manual input..." "$COLOR_BLUE"
    
    # Read the .env file line by line
    while IFS= read -r line || [ -n "$line" ]; do
        # Check if the line contains the placeholder <MANUAL_INPUT_NEEDED ...>
        if [[ "$line" == *"=<MANUAL_INPUT_NEEDED"* ]]; then
            log_output "[TODO] $line" "$COLOR_RED"
            ACTION_ITEM_COUNT=$((ACTION_ITEM_COUNT + 1))
            output_color="$COLOR_RED"
        fi
    done < "$env_file"
    
    if [ "$ACTION_ITEM_COUNT" -eq "$original_action_item_count" ]; then
        log_output "Complete." "$COLOR_GREEN"
    fi
}

# Function to check if there are any action items that need to be completed
# based on the ACTION_ITEM_COUNT variable.
# If there are action items, it will log them and exit with an error code.
# Usage: env_check_action_items
env_check_action_items() {
    if [ "$ACTION_ITEM_COUNT" -gt "0" ]; then
      log_output "Found $ACTION_ITEM_COUNT action(s) that need to be completed. See [TODO] items in red above and run this check again once they are completed." "$COLOR_RED"
      exit 1
    else
      log_output "No actions required, .env ready for use." "$COLOR_GREEN"
    fi
}

# Main function to run all checks on the .env file
# Usage: env_run_all_checks <env_file> <env_file_template> <env_file_tmp>
env_run_all_checks() {
    local env_file="$1"
    local env_file_template="$2"
    local env_file_tmp="$3"
    
    env_create_file "$env_file" "$env_file_template"
    env_generate_passwords "$env_file" "$env_file_tmp"
    env_check_missing_vars "$env_file" "$env_file_template"
    env_check_missing_values "$env_file"
    env_check_action_items
}